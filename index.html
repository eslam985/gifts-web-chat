<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Ø£Ø¨ÙˆØª Ù…ØªØ¬Ø± Ø§Ù„Ù‡Ø¯Ø§ÙŠØ§ (ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ÙˆÙŠØ¨)</title>
 <!-- Tailwind CSS CDN -->
 <script src="https://cdn.tailwindcss.com"></script>
 <!-- React and Babel for in-browser JSX compilation -->
 <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
 <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
 <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
 <!-- Lucide Icons -->
 <script src="https://unpkg.com/lucide-react@latest/dist/umd/lucide-react.js"></script>
 <style>
  body {
   font-family: 'Inter', sans-serif;
   background-color: #f7f7f7;
   display: flex;
   justify-content: center;
   align-items: flex-start;
   min-height: 100vh;
   padding-top: 2rem;
   padding-bottom: 2rem;
  }

  #root {
   width: 100%;
   max-width: 480px;
   box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
  }

  /* Custom scrollbar for chat area */
  .chat-area::-webkit-scrollbar {
   width: 8px;
  }

  .chat-area::-webkit-scrollbar-thumb {
   background: #d1d5db;
   /* gray-300 */
   border-radius: 10px;
  }

  .chat-area::-webkit-scrollbar-track {
   background: #f3f4f6;
   /* gray-100 */
  }
 </style>
</head>

<body>

 <div id="root"></div>

 <script type="module">
  // Firebase Imports
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
  import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
  import { getFirestore, collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
  import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

  // setLogLevel('debug'); // Enable for debugging Firestore issues

  window.firebase = {
   initializeApp,
   getAuth,
   signInAnonymously,
   signInWithCustomToken,
   onAuthStateChanged,
   getFirestore,
   collection,
   query,
   orderBy,
   onSnapshot,
   addDoc,
   serverTimestamp,
   limit,
   setLogLevel
  };
 </script>

 <script type="text/babel">
  const { useState, useEffect, useRef, useCallback } = React;
  const { Sparkles, Send, Loader2 } = lucide;

  // === CONFIGURATION AND CONSTANTS ===
  const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
  const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
  const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

  // Webhook URL
  const WEBHOOK_URL = 'https://gifts-bot-webhook.vercel.app/webhook';

  // Helper for generating UUID
  const generateUUID = () => crypto.randomUUID();

  // === FIREBASE INITIALIZATION AND AUTH HOOK ===
  const useFirebase = () => {
   const [db, setDb] = useState(null);
   const [auth, setAuth] = useState(null);
   const [userId, setUserId] = useState(null);
   const [isAuthReady, setIsAuthReady] = useState(false);

   useEffect(() => {
    const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore } = window.firebase;

    try {
     const app = initializeApp(firebaseConfig);
     const firestore = getFirestore(app);
     const authInstance = getAuth(app);

     setDb(firestore);
     setAuth(authInstance);

     const unsubscribe = onAuthStateChanged(authInstance, async (user) => {
      if (!user) {
       try {
        if (initialAuthToken) {
         await signInWithCustomToken(authInstance, initialAuthToken);
        } else {
         await signInAnonymously(authInstance);
        }
       } catch (error) {
        console.error("Firebase Auth Error:", error);
       }
      }
      // Use uid if logged in, otherwise use a generated anonymous ID
      setUserId(authInstance.currentUser?.uid || generateUUID());
      setIsAuthReady(true);
     });

     return () => unsubscribe();
    } catch (e) {
     console.error("Firebase Initialization Failed:", e);
     setIsAuthReady(true);
    }
   }, []);

   return { db, auth, userId, isAuthReady };
  };

  // === MESSAGE RENDERING COMPONENTS ===

  // ğŸ›‘ Component to render Quick Replies as buttons
  const QuickReplies = ({ replies, onQuickReplyClick }) => {
   if (!replies || !replies.quickReplies || replies.quickReplies.length === 0) return null;

   const buttons = replies.quickReplies;
   const title = replies.title || "Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:";

   return (
    <div className="flex flex-col items-start mt-2 p-2 bg-gray-50 border-t border-gray-200 rounded-b-xl shadow-inner">
     <p className="text-xs text-gray-500 mb-2 font-medium">{title}</p>
     <div className="flex flex-wrap gap-2">
      {buttons.map((reply, index) => (
       <button
        key={index}
        onClick={() => onQuickReplyClick(reply)}
        className="px-3 py-1 text-sm bg-blue-500 text-white rounded-full hover:bg-blue-600 transition duration-150 shadow-md transform hover:scale-[1.02] active:scale-[0.98] whitespace-nowrap"
        style={{ minWidth: '80px' }}
       >
        {reply}
       </button>
      ))}
     </div>
    </div>
   );
  };


  const MessageBubble = ({ message, onQuickReplyClick }) => {
   const isBot = message.role === 'bot';
   const alignClass = isBot ? 'justify-start' : 'justify-end';
   const bgColor = isBot ? 'bg-gray-100' : 'bg-blue-500';
   const textColor = isBot ? 'text-gray-800' : 'text-white';
   const borderRadius = isBot ? 'rounded-tl-xl rounded-tr-xl rounded-br-xl' : 'rounded-tl-xl rounded-tr-xl rounded-bl-xl';

   let textContent = message.text;
   let quickRepliesData = null;

   // ğŸ›‘ LOGIC: Parse Rich Content from fulfillmentMessages (for bot responses only)
   if (isBot && message.response?.fulfillmentMessages) {
    for (const fulfillmentMessage of message.response.fulfillmentMessages) {

     // Extract Quick Replies
     if (fulfillmentMessage.quickReplies && fulfillmentMessage.quickReplies.quickReplies && fulfillmentMessage.quickReplies.quickReplies.length > 0) {
      quickRepliesData = fulfillmentMessage.quickReplies;
     }

     // Extract Text Content (Prioritize the text from the message array if available)
     if (fulfillmentMessage.text && fulfillmentMessage.text.text?.[0]) {
      textContent = fulfillmentMessage.text.text[0];
     }
    }
   }

   // Use the main fulfillmentText as fallback if no text was explicitly pulled
   textContent = textContent || message.response?.fulfillmentText || "ØªØ¹Ø°Ø± Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø¯.";


   return (
    <div className={`flex w-full mb-4 ${alignClass}`}>
     <div className={`max-w-[85%] sm:max-w-[70%] lg:max-w-[60%]`}>
      <div className={`p-3 shadow-md ${bgColor} ${textColor} ${borderRadius}`}>
       {/* Use dangerouslySetInnerHTML to allow HTML tags for contact info link */}
       <div className="text-right whitespace-pre-wrap" dangerouslySetInnerHTML={{ __html: textContent }}></div>
      </div>

      {/* ğŸ›‘ Render Quick Replies if found */}
      {isBot && quickRepliesData && (
       <QuickReplies replies={quickRepliesData} onQuickReplyClick={onQuickReplyClick} />
      )}
     </div>
    </div>
   );
  };

  // === MAIN CHAT APPLICATION ===

  const App = () => {
   const { db, userId, isAuthReady } = useFirebase();
   const [input, setInput] = useState('');
   const [messages, setMessages] = useState([]);
   const [isLoading, setIsLoading] = useState(false);
   const messagesEndRef = useRef(null);
   const [sessionId] = useState(generateUUID()); // Session ID generated once per load

   const { collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, limit } = window.firebase;


   // Scroll to the latest message
   const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
   };

   // ğŸ›‘ API Call Function: Sends message to the Vercel Webhook
   const sendApiRequest = useCallback(async (queryText) => {
    setIsLoading(true);

    // 1. Prepare request body in the custom format required by the webhook proxy
    const requestBody = {
     queryInput: {
      text: { text: queryText }
     },
     sessionId: sessionId,
     customPayload: true, // Marker for the server to recognize the React UI request
    };

    const maxRetries = 3;
    const initialDelay = 1000; // 1 second

    const executeFetch = async (attempt) => {
     try {
      const response = await fetch(WEBHOOK_URL, {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
       const errorText = await response.text();
       throw new Error(`HTTP error! Status: ${response.status}. Message: ${errorText}`);
      }

      return response.json();

     } catch (error) {
      if (attempt < maxRetries) {
       const delay = initialDelay * Math.pow(2, attempt);
       // Do not log retry as an error
       await new Promise(resolve => setTimeout(resolve, delay));
       return executeFetch(attempt + 1);
      }
      throw error;
     }
    };

    try {
     const botResponse = await executeFetch(0);

     // 2. Add bot response to Firestore
     if (db && userId) {
      const messagesCol = collection(db, `artifacts/${appId}/users/${userId}/messages`);
      await addDoc(messagesCol, {
       role: 'bot',
       text: botResponse.fulfillmentText, // Fallback text
       response: botResponse, // Store full response to access rich content
       timestamp: serverTimestamp(),
       sessionId: sessionId,
      });
     }

    } catch (error) {
     console.error("API Call FAILED:", error);
     // Add error message to the chat display
     if (db && userId) {
      const messagesCol = collection(db, `artifacts/${appId}/users/${userId}/messages`);
      await addDoc(messagesCol, {
       role: 'bot',
       text: `ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Webhook ÙŠØ¹Ù…Ù„ ÙˆØ£Ù† Ø§Ù„Ø±Ø§Ø¨Ø· ØµØ­ÙŠØ­. Ø§Ù„Ø±Ø³Ø§Ù„Ø©: ${error.message || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ.'}`,
       timestamp: serverTimestamp(),
       sessionId: sessionId,
      });
     }

    } finally {
     setIsLoading(false);
    }
   }, [db, userId, sessionId]);

   // ğŸ›‘ Function to handle sending a message (user input or quick reply click)
   const sendMessage = useCallback(async (queryText) => {
    if (!queryText.trim() || isLoading || !db || !userId) return;

    const textToSend = queryText.trim();
    setInput(''); // Clear input box

    // 1. Add user message to Firestore
    const messagesCol = collection(db, `artifacts/${appId}/users/${userId}/messages`);
    await addDoc(messagesCol, {
     role: 'user',
     text: textToSend,
     timestamp: serverTimestamp(),
     sessionId: sessionId,
    });

    // 2. Send API request and handle bot response
    await sendApiRequest(textToSend);

   }, [isLoading, db, userId, sendApiRequest, sessionId]);

   // Handle form submit
   const handleSubmit = (e) => {
    e.preventDefault();
    sendMessage(input);
   };

   // ğŸ›‘ Firestore Listener for Real-time Chat History
   useEffect(() => {
    if (!isAuthReady || !db || !userId) return;

    const messagesCol = collection(db, `artifacts/${appId}/users/${userId}/messages`);
    const q = query(messagesCol, orderBy('timestamp', 'asc'), limit(50));

    // Use onSnapshot to listen for real-time updates
    const unsubscribe = onSnapshot(q, (snapshot) => {
     const loadedMessages = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      timestamp: doc.data().timestamp?.toDate(), // Convert Firestore Timestamp to Date object
     })).filter(msg => msg.sessionId === sessionId); // Filter by current session

     setMessages(loadedMessages);
     scrollToBottom();
    }, (error) => {
     console.error("Firestore Error:", error);
    });

    // Clean up the listener on component unmount
    return () => unsubscribe();
   }, [isAuthReady, db, userId, sessionId]);

   // Initial welcome message and scroll on load
   useEffect(() => {
    scrollToBottom();
   }, [messages]);

   // Check if the initial welcome message has been sent for this session
   useEffect(() => {
    if (isAuthReady && db && userId && messages.length === 0 && !isLoading) {
     // Send a 'Ù…Ø±Ø­Ø¨Ø§' message to trigger the Default Welcome Intent
     const sendInitialMessage = async () => {
      const messagesCol = collection(db, `artifacts/${appId}/users/${userId}/messages`);
      // Add a dummy message to Firestore to prevent re-triggering this effect
      // We use a different role/temp status here
      await addDoc(messagesCol, {
       role: 'system',
       text: 'Starting session...',
       timestamp: serverTimestamp(),
       sessionId: sessionId,
      });
      await sendApiRequest('Ù…Ø±Ø­Ø¨Ø§');
     };
     sendInitialMessage();
    }
   }, [isAuthReady, db, userId, messages.length, isLoading, sendApiRequest, sessionId]);


   if (!isAuthReady) {
    return (
     <div className="flex items-center justify-center h-screen bg-gray-50 text-gray-700">
      <Loader2 className="animate-spin ml-2 h-6 w-6 text-blue-500" />
      <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©...</p>
     </div>
    );
   }

   return (
    <div className="min-h-screen bg-gray-50 flex flex-col items-center p-4">
     {/* Header */}
     <header className="w-full max-w-xl bg-white shadow-lg rounded-t-xl p-4 flex items-center justify-between border-b border-blue-500">
      <div className="flex items-center">
       <Sparkles className="w-6 h-6 text-blue-500 ml-2" />
       <h1 className="text-xl font-bold text-gray-800">Ø£Ø¨ÙˆØª Ù…ØªØ¬Ø± Ø§Ù„Ù‡Ø¯Ø§ÙŠØ§ (React Custom UI)</h1>
      </div>
      <div className="text-sm text-gray-500">
       <span className="font-mono bg-gray-100 p-1 rounded-md text-xs">{userId.substring(0, 8)}...</span>
      </div>
     </header>

     {/* Chat Area */}
     <div className="flex-1 w-full max-w-xl bg-white overflow-hidden shadow-lg mb-4" style={{ height: '70vh' }}>
      <div className="h-full overflow-y-auto p-4 flex flex-col chat-area" style={{ direction: 'rtl' }}>

       {messages.filter(msg => msg.role !== 'system').map((msg) => (
        <MessageBubble
         key={msg.id}
         message={msg}
         onQuickReplyClick={sendMessage}
        />
       ))}

       {isLoading && (
        <div className="flex justify-start mb-4">
         <div className="p-3 bg-gray-100 text-gray-500 rounded-tl-xl rounded-tr-xl rounded-br-xl shadow-md flex items-center">
          <Loader2 className="animate-spin ml-2 h-4 w-4" />
          <span className="text-sm">Ø§Ù„Ø¨ÙˆØª ÙŠÙÙƒØ±...</span>
         </div>
        </div>
       )}
       <div ref={messagesEndRef} />
      </div>
     </div>

     {/* Input Form */}
     <form onSubmit={handleSubmit} className="w-full max-w-xl bg-white shadow-2xl rounded-xl p-3 flex items-center border border-gray-200">
      <input
       type="text"
       value={input}
       onChange={(e) => setInput(e.target.value)}
       placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ..."
       disabled={isLoading}
       className="flex-1 p-3 border-none focus:ring-0 focus:outline-none text-right placeholder-gray-400 text-gray-800"
       dir="rtl"
      />
      <button
       type="submit"
       disabled={isLoading || !input.trim()}
       className={`p-3 rounded-full transition duration-200 transform ${isLoading || !input.trim()
        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
        : 'bg-blue-500 hover:bg-blue-600 text-white shadow-lg hover:scale-105 active:scale-95'
        }`}
      >
       <Send className="w-5 h-5" />
      </button>
     </form>
    </div>
   );
  };

  ReactDOM.render(<App />, document.getElementById('root'));

 </script>

</body>

</html>